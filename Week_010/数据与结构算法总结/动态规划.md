#### **动态规划**

**动态规划问题的一般形式就是求最值.**(如:求最长递增子序列等)动态规划其实是运筹学的一种最优化方法.

<font color=red>求解动态规划的核心问题是穷举.动态规划问题一定会具备[最优子结构],只有列出正确的[状态转移方程]才能正确地穷举.</font>

<font color= orange>重叠子问题、最优子结构、状态转移方程就是动态规划的三要素.</font>

明确base case -> 明确[状态] -> 明确[选择] -> 定义dp数组/函数的含义.

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

**一、斐波那契数列**

主要是让我明白什么是重叠子问题.

1. 暴力递归

   斐波那契数列的数学形式就是递归:

   ```java
   int fib(int N) {
     if(N == 1 || N == 2) return 1;
     return fib(N - 1) + fib(N - 2);
   }
   ```

   **递归算法时间复杂度怎么计算?就是用子问题个数乘以解决一个子问题需要的时间.**

   + 首先计算子问题个数,即递归树中节点的总数.二叉树节点总数为指数级别,所以子问题个数为O(2^n).
   + 然后计算解决一个子问题的时间,在本算法中,没有循环,只有`f(n-1) + f(n - 2)`一个加法操作,时间为O(1).
   + 所以,这个算法的时间复杂度为O(2^n).

2. 带记录的递归解法

   ```c++
   public int fib(int N) {
     if(N < 1) return 0;
     // 记录全初始化为0
      int[] memo = new int[N + 1];
     // 进行带记录的递归
     return heper(memo, N);
   }
   public int helper(int[] memo, int n) {
     // base case
     if(n == 1 || n == 2) return 1;
     if(memo[n] != 0) return memo[n];
     memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
     return memo[n];
   }
   ```

   以上这种解法和迭代的动态规划,叫做[自顶向下]、[自底向上].啥叫[自底向上]?反过来直接从最底下,问题规模最小的`f(1)` 和 ` f(2)`开始往上推,直到推到我们想要的答案`f(20)`,这就是动态规划的思路.

3. dp数组的迭代解法

   ```c++
    int fib(int N) {
     int[] dp = new int[N + 1];
       // base case
       dp[1] = dp[2] = 1;
       for (int i = 3; i <= N; i++)
           dp[i] = dp[i - 1] + dp[i - 2];
       return dp[N];
   }
   ```

   状态转移方程这个名词,实际上就是描述问题结构的数学形式:
   $$
   f(n) =⎨1,n = 1, 2 \qquad
           f(n - 1) + f(n - 2), n > 2⎬
   $$
   啥叫[状态转移方程] 把f(n)想做一个状态n, 这个状态n是由状态 `n - 1`和状态`n - 2`相加转移而来,这就叫状态转移.

   根据斐波那契数列的状态转移方程,当前状态只和之前的两个状态有关,所以不需要用一个dp table来存储所有的状态,只要想办法存储之前的两个状态就行了.所以可以进一步优化,把空间复杂度降为O(1):

   ```java
    int fib(int n) {
       if (n == 2 || n == 1) 
           return 1;
       int prev = 1, curr = 1;
       for (int i = 3; i <= n; i++) {
           int sum = prev + curr;
           prev = curr;
           curr = sum;
       }
       return curr;
   }
   ```

   这个技巧就是所谓的[状态压缩].

**二、凑零钱问题**

```java
// coins中是可选硬币面值,amount是目标金额
 int coinChange(int[] coins, int amount);
```

1. 暴力递归

   **<font color=red>要符合[最优子结构],子问题间必须互相独立.</font>**

   **如何列出正确的状态转移方程?**
   
   1. **确定base case,**目标金额amount为0时算法返回0,因为不需要任何硬币就已经凑出目标金额了.
   
   2. **确定[状态],也就是原问题和子问题中会变化的变量.**由于硬币数量无限,硬币的面额是已知的,目标金额会不断地向base case靠近,所以唯一的[状态]就是目标金额`amount`.
   
   3. **确定[选择],也就是导致[状态]产生变化的行为.**目标金额为什么变化呢,每选择一枚硬币,就相当于减少了目标金额.所以说所有硬币的面值 ,就是你的[选择].
   
   4. **明确`dp`函数/数组的定义.**自顶向下的解法,会有一个递归的`dp`函数,一般来说函数的参数就是状态转移中会变化的量,也就是上面说到的[状态];函数的返回值就是题目要求计算的量.所以可以这样定义`dp`函数:
   
      `dp(n)`的定义: 输入一个目标金额`n`,返回凑出目标金额`n`的最少硬币数量.
   
      

